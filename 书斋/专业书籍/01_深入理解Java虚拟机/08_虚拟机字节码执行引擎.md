# 8 虚拟机字节码执行引擎

## 8.1 概述

## 8.2 运行时栈帧结构

![栈帧的概念结构](hello/frame.png)

栈帧（Stack Frame）用于支持方法调用和方法执行的数据结构。

它是虚拟机运行时数据区中的虚拟机栈的栈元素，存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。

每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈道出栈的过程。

每一个两点都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。

执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。

### 8.2.1 局部变量表

一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。方法的Code属性max_locals确定局部变量表分配最大容量。

局部变量表的容量以变量槽（Variable Slot）为最小单位，每一个Slot（32位）都应该能放一个 boolean 、byte 、char 、float 、 reference 、 short 、 int 或 returnAddress 类型数据。而至于 long 、double 两种数据则被规定为是64位数据（连续两个32位）。

reference类型数据可能是32位，也可能是64位数据。这个类型表示对一个对象实例的引用。虚拟机实现至少都应当能通过这个引用做到两点:

- 从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引。
- 此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息,否则无法实现Java语言规范中定义的语法约束约束。

this为第0位索引的slot。

由于局部变量表中的slot是可复用的，如果当前字节码PC计数器的值已经超出了某个变量作用域，那这个变量对应的slot就可以交给其他变量使用。但是，伴随一些额外的副作用，如会直接影响到系统的垃圾收集行为。如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值便是一个有意义的操作。

但从编码的角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法。再说，经过JIT编译器后，赋null值的操作会被消除掉。

### 8.2.2 操作数栈

后入先出。编译的时候写入Code属性的max_stacks数据项中。

### 8.2.3 动态连接

每个栈帧都包含一个指向运行时常量池中的该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

Class文件中的常量池存在大量符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

### 8.2.4 方法返回地址

- 正常退出。遇到任意一个方法返回的字节码指令，正常完成出口。
- 异常退出。

### 8.2.5 附加信息

## 8.3 方法调用

方法调用不等于方法执行，唯一目标是确定被调用方法的版本(即调用哪一个方法)，暂时还不涉及方法内部的具体运行过程。

### 8.3.1 解析

该阶段将常量池中的符号引用转化为直接引用，前提是在程序真正运行之前就有一个可的调用版本。

- 虚方法。(除去final)。
- 非虚方法。被invokestatic和invokespecial指令调用的方法，在解析阶段中确定唯一调用版本，如静态方法、私有方法、实例构造器、父类方法。它们在类加载的时候就会把符号引用解析为该方法的直接引用。

解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派(Dispatch)调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。

### 8.3.2 分派

Java面向对象3个基本特征: 继承、封装和多态。

1. 静态分派

   ```java
   class Humam{}
   class Man extends Humam{}
   class Woman extends Humam{}
   public void sayHello(Human guy){System.out.println("guy")}
   public void sayHello(Man guy) {System.out.println("gentelman")}
   public void sayHello(Woman guy) {System.out.println("lady")}
   
   Human man = new Man();
   Human woman = new Woman();
   sr.sayHello(man);
   sr.sayHello(woman);
   
   // 运行结果
   // guy
   // guy    
   ```

   `Human man = new Man();`Human称为静态类型，Man为变量的实际类型。编译器在重载时是通过参数静态类型而不是实际类型作为判定依据。       7			 

2. 动态分派

3. 单分派和多 分派

4. 虚拟机动态分派的实现

### 8.3.3 动态类型语言支持

## 8.4 基于栈的字节码解析执行引擎

### 8.4.1 解释执行    

### 8.4.2 基于栈的指令集与基于寄存器的指令集

### 8.4.3 基于栈的解释器执行过程

