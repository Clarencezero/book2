# 虚拟机类加载机制

## 7.1 概述

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类的加载机制。

![JVM 加载 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi//jvm load.png)

C/C++需要在编译时进行连接工作。但是 Java 中, 类型的加载、连接和初始化过程都是在程序运行期间完成的。

如编写一个面向接口的应用程序, 可以等到运行时再指定其实际的实现类。

## 7.2 类加载的时机

## 7.3 类加载的过程

![类的生命周期 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi//class life.png)

加载、验证、准备、初始化和卸载这 5 个阶段的顺序固定。类的加载必须按照此顺序进行。**而解析**阶段则不一定, 它在某些情况下可以在初始化阶段之后再开始, 是为了支持 Java**语言的运行时绑定**。**即动态绑定**。

对于初始化阶段, 虚拟机规范如下:

- 遇到**new、getstatic、putstaticinvokestatic**这 4 条字节码指令时，如果类没有初始化，则需要先出发其初始化。生成这 4 条指令的典型场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段的时候（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法的时候
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候
- 当初始化一个类时，如果发现它的父类还没有进行初始化，则需要先触发其父类进行初始化
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main 方法的类），虚拟机会先初始化这个类
- 当使用 JDK1.7 的动态语言支持时,如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄,并且这个方法句柄所对应的类没有进行过初始化,则需要先触发其初始化。

这 5 种场景中的行为被称为对一个类进行主动引用。除此之外, 所有引用类的方式都不会触发初始化, 称为被动引用。

1. 案例一

```java
package org.fenixsoft.classloading;
/*
* 被动使用类字段演示一：
* 通过子类引用父类的静态字段，不会导致子类初始化
*/
public class Superclass {
    static {
        System.out.printin("Superclass init!");
    }
    public static int value = 123;
}
public class SubClass extends Superclass {
    static {
       	System.out・printin("Subclass init!");
   	}
}

public class Notinitialization {
	public static void main(String(] args) {
		System.out.pirintin (SubClass.value);
	}
}
// 只会输出 SuperClass Init!。
// 对于静态字段,只有直接定义这个字段的类都会被初始化,因此通过其子类来引用父类中定义的静态字段,只会触发父类的初始化而不会触发子类的初始化。至于是否触发子类的加载和验证,在虚拟机规范中并未明确规定,这点取决于虚拟机的具体实现。
```



2. 案例二

```java
SuperClass[] sca = new SuperClass[10];
```

运行之后也不会输出 SuperClass init!,说明没有触发类 SuperClass 的初始化阶段。但是触发了[**Lorg.xx.SuperClass**的类的初始化阶段。这是由虚拟机自动生成的、直接继承于**java.lang.Object**的子类。创建指令由**newarray**触发。

### 7.3.1 加载

加载是类加载的一个阶段，注意不要混淆。

加载过程完成以下三件事：

- 通过类的**完全限定名称**获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

数组不通过类加载器创建, 由 Java 虚拟机直接创建。

加载阶段完成, 外部的二进制字节流按虚拟机所需的格式存储在方法区, 数据存储格式由虚拟机实现自行定义。并在内存中实例化一个**java.lang.Class**类的对象 (并没有明确规定是 Java 堆中,对于 HotSpot 虚拟机而言,Class 对象比较特殊,它虽然是对象,但是存放在方法区里面), 这个对象将作为程序访问方法区中的这些类型数据的外部接口。

### 7.3.2 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

### 7.3.3 准备

类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。

实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

```java
public static int value = 123;
```

如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。把 value 设置为 123 的动作是在初始化动作开始, 因为编译时把此动作的字节码存放在 `<clinit>()` 方法中。

```java
public static final int value = 123;
```

### 7.3.4 解析

虚拟机将常量池的符号引用替换为直接引用的过程。

> 符号引用在 Class 文件中以**CONSTANT_Class_info**、**CONSTANT_Fieldref_info**、**CONSTANT_Methodref_info**等类型的常量出现。

- 符号引用 (Symbolic Reference)。可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。
- 直接引用 (Direct Reference)。可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。

虚拟机实现可以根据需求来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析。

除 invokedynamic 指令以外，虚拟机对第一次解析的结果进行缓存 (在运行时常量池中记录直接引用，并把常量标识为已解析状态) 从而避免解析动作重复进行。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。

### 7.3.5 初始化

类加载过程的最后一步。从这里开始真正执行类中定义的 Java 代码 (字节码)。

初始化阶段执行的类构造器``<clinit>()`` 方法。

1. `<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块 (static{} 块) 中的语句合并产生。
2. 与 `<init>()` 不同，不需要地调用父类构造器。虚拟机保证父类的 `<clinit>()` 执行在子类之前。
3. 接口中有变量初始化操作，都会生成 `<clinit>()` 方法。当父接口的变量使用时，父接口才会初始化。
4. 虚拟机保证一个类的 `<clinit>()` 方法在多线程环境中被正确地回销、同步。

## 7.4 类加载器

通过一个类的全限定名来获取描述此类的二进制字节流。 

### 7.4.1 类与类加载器

类加载器只适用于类的加载动作，但不限于类加载阶段。

### 7.4.2 双亲委派模型

从虚拟机角度看，只存在两种不同的类加载器

- 启动类加载器 (Bootstrap ClassLoader)。C++实现，虚拟机自身的一部分。
- 其他的类加载器。由 Java 语言实现。独立于虚拟机外部，全部继承 java.lang.ClassLoader。

![类加载器双亲委派模型 ](https://cdn.jsdelivr.net/gh/Clarencezero/poi//chapter7 parent model.png)

工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈无法完成这个加载请求 (它的搜索范围中没有找到所需的类) 时，子加载器都会尝试自己去加载。

### 7.4.3 破坏双亲委派模型

1. 第二次被破坏是由于这个模型本身缺陷所导致的。是因为基础类又要调用回用户的代码。如**JNDI**服务。
2. 第三次被破坏是由于用户对程序动态性的追求导致。如代码热替换、模块热部署等。

相关 SPI 文章可以查看以下链接

- [深入理解 Java SPI 机制 张硕 ](https://blog.csdn.net/lemon89/article/details/79189475)
- [【Java】深入理解 Java 中的 spi 机制 ](https://blog.csdn.net/lemon89/article/details/79189475)

## 7.5 小结